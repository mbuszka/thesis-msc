\chapter{Semantics Transformer}\label{chapter:transformer}
The adaptation of the functional correspondence into a semantics transformer was the main goal of this thesis.
Although the two main transformations considered here are widely known, they are not presented in literature in a form directly applicable for the task.
As the goal of the algorithm is to produce a definition of an abstract machine, to be read as a source code, care has to be taken to produce readable results.
To this end I chose to allow for partial CPS translation, with functions which should be left alone marked with annotations.
This approach allows one to specify helper functions whose control-flow is not particularly interesting to capture, such as environment lookups.
The defunctionalization is usually presented as a manual transformation, with human-specified function spaces or in a type directed fashion, where all functions of a particular type end up in the same bag.
Neither of these approaches are satisfying for the purposes of a semantics transformer as the goal is to produce the result automatically and to uncover the operational properties of the evaluator.
I also chose to allow for partial defunctionalization of programs, as it permits one to keep some parts of the machine abstract (e.g. functions modelling a heap or an environment).
The partitioning of function spaces is done using results of control-flow analysis which approximates the runtime behavior of programs.
This approach allows for functions of the same type to land in different spaces based on their usage in a program.
Finally, as the transformation generates new variables and moves code around we have to keep them readable.
Current implementation employs some heuristics and optional annotations to keep the names under control and inlines most of the introduced intermediate terms.

The abstract syntax of \IDL{} is presented in Figure \ref{fig:idl-abs-syntax}.
The meta-variables $x, y, z$ denote variables; $r$ denote structure (aka record) names; $s$ is used to denote string literals and $b$ is used for all literal values -- strings, integers and booleans.
The meta-variable $\mathit{tp}$ is used in pattern matches which check whether a value is one of the primitive types.
The patterns are referred to with variable $p$ and may be a variable, a literal value, a wildcard, a record pattern or a type test.
Terms are denoted with variable $t$ and are one of variable, literal value, anonymous function, application, record constructor, let binding (which may destructure bound term with a pattern), pattern match or an error expression.

In the remainder of this chapter I will describe the four stages of the transformation: translation to administrative normal form, selective translation to continuation-passing style, selective defunctionalization and let-inlining.
I will also describe the algorithm used to compute the control-flow analysis.


\begin{figure}
\begin{center}
\begingroup
\setlength{\tabcolsep}{2pt}
\begin{tabular}{rrl}
  $x, y, z \in Var$ && $r\in StructName$\quad$s \in String$ \quad $b \in Int \cup Boolean \cup String$\\
  $Tp \ni \mathit{tp} $ &::=& \lstinline!String! | \lstinline!Integer! | \lstinline!Boolean!\\
  $Pattern \ni p $ &::=& $x$ | $b$ | \lstinline!_! | \lstinline!{$r$ $p\ldots$}! |  \lstinline![$\mathit{tp}$ $x$]!\\
  $Term \ni t$ &::=& $x$ | $b$
              | \lstinline!(fun ($x\ldots$) $t$)!
              | \lstinline!($t$ $t\ldots$)!
              | \lstinline!{$t$ $t\ldots$}!\\
              &|& \lstinline!(let $p$ $t$ $t$)!
              | \lstinline!(match $t$ ($p$ $t$)$\ldots$)!
              | \lstinline!(error $s$)!\\
  $FunDef \ni \mathit{fd}$ &::=& \lstinline!(def $x$ ($x\ldots$) $t$)!\\
  $StructDef \ni \mathit{sd}$ &::=& \lstinline!(def-struct {$r$ $x\ldots$})!\\
\end{tabular}
\endgroup
\end{center}
\caption{Abstract syntax of \IDL{}}\label{fig:idl-abs-syntax}
\end{figure}


\section{Administrative Normal Form}
The administrative normal form (ANF) \cite{flanagan-anf} is an intermediate representation for functional languages in which all intermediate results are let-bound to names.
This shape greatly simplifies later transformations as programs do not have complicated sub-expressions.
From operational point of view, the only place where a continuation is grown when evaluating program in ANF is a let-binding.
This property ensures that a program in ANF is also much easier to evaluate using an abstract machine which will be taken advantage of in Section \ref{sec:transformer-cfa}.
The abstract syntax of terms in ANF and an algorithm for transforming \IDL{} programs into such form is presented in Figure \ref{fig:transformer-anf}.
The terms are partitioned into three levels: variables, commands and expressions.
Commands $c$ extend variables with values -- base literals, record constructors (with variables as sub-terms) and abstractions (whose bodies are in ANF); and with redexes like applications of variables and match expressions (which match on variable and have branches in ANF).
Expressions $e$ in ANF have the shape of a possibly empty sequence of let-bindings ending with either an error term or a command.

The $\anf{\cdot}{\cdot}$ function, written in CPS, is the main transformation function.
Its arguments are term to be transformed and a meta-continuation (i.e. a continuation in meta-language) which will be called to obtain the term for the rest of transformed input.
This function decomposes the term according to the evaluation rules and uses two helper functions.
Function $\atomic{\cdot}$ transforms a continuation expecting an atomic expression (which are created when transforming commands) into one accepting any command by let-binding passed argument $c$ when necessary.
Function $\anfSeq{\cdot}{\cdot}$ sequences computation of multiple expressions by creating a chain of let-bindings (using $\atomic{\cdot}$) and then calling the continuation with created variables.

TODO:
- better characterization of the ANF
- describe the algorithm
- explain why this particular form

\begin{figure}
\begin{center}
\begingroup
\setlength{\tabcolsep}{2pt}
\begin{tabular}{rll}
  $Command \ni c $ && ::= $x$ | $b$
  | \lstinline!(fun ($x\ldots$) $e$)!
  | \lstinline!($x$ $x\ldots$)!\\
  &&| \lstinline!{$r$ $x\ldots$}!
  | \lstinline!(match $x$ ($p$ $e$)$\ldots$)!\\
  $Expression \ni e $ && ::= $c$ 
  | \lstinline!(let $p$ $c$ $e$)!
  | \lstinline!(error $s$)!\\
  
  % $id\,x$ &&$= x$\\
  \hline\\
  $\bb{\cdot}$ &$\cdot$ &: $Expr \times (Com \rightarrow Anf) \rightarrow Anf$\\
  $\bb{a}$ &$k$ &$= k\,a$\\
  
  $\bb{\lstinline!(fun ($x\ldots$)\ $e$)!}$ &$k$
  & $= k\, \lstinline!(fun ($x\ldots$) $\anf{e}{id}$)!$\\
  
  $\bb{\lstinline!($e_f \; e_{arg}\ldots$)!}$ &$k$ 
  &$= \anf{e_f}{\atomic{\lambda a_f . \anfSeq{e_{arg}\ldots}{\lambda (a_{arg}\ldots) . k \,\lstinline!($a_f\;a_{arg}\ldots$)!}}}$\\

  $\bb{\lstinline!(let\ $x\;e_1\;e_2$)!}$ & $k$
  &$= \anf{e_1}{\lambda e_1' . \lstinline!(let\ $x\;e_1'\;\anf{e_2}{k}$)!}$\\

  $\bb{\lstinline!\{$r \; e\ldots$\}!}$ &$k$ 
  &$= \anfSeq{e\ldots}{\lambda (a\ldots) . k \,\lstinline!\{$r\;a\ldots$\}!}$\\

  $\bb{\lstinline!(match\ $e$\ ($p \;e_b$))!}$ & $k$
  &$= \anf{e}{\atomic{\lambda e' . k\,\lstinline!(match\ $e'\;$($p\;\anf{e_b}{id}$)!}}$\\

  $\bb{\lstinline!(error\ $s$)!}$ & \_ & $= $ \lstinline!(error $s$)!\\

  \hline\\
  $[\cdot]_a$ & $\cdot$ & : $(Atomic \rightarrow Anf) \rightarrow Com \rightarrow Anf$\\
  $[k]_a$ & $a$ & $= k\,a$\\
  $[k]_a$ & $c$ & $= $ \lstinline!(let $x$ $c$ $(k\,x)$)!\\
  \hline\\
  $\bb{\cdot}_s$ & $\cdot$ &: $Expr^* \times (Atomic^* \rightarrow Anf) \rightarrow Anf$\\
  $\bb{e\ldots}_s$ & $k$ & $= \bb{e\ldots}_s^{\epsilon}$\\
  $\bb{\epsilon}_s^{a\ldots}$ & $k$ & $= k\,(a\ldots)$\\
  $\bb{e\,e_r\ldots}_s^{a_{acc}\ldots}$ & $k$ & 
  $= \anf{e}{\atomic{\lambda a . \bb{e_r\ldots}_s^{a_{acc}\ldots a}}}$

\end{tabular}
\endgroup
\end{center}
\caption{ANF transformation for \IDL{}}
\label{fig:transformer-anf}
\end{figure}


\section{Control-Flow Analysis}\label{sec:transformer-cfa}
The analysis most relevant to the task of deriving abstract machines from interpreters is the control-flow analysis.
Its objective is to find for each expression in a program an over-approximation of a set of functions it may evaluate to \cite{popa}.
This information can be used in two places: when determining whether a function and applications should be CPS transformed and for checking which functions an expression in operator position may evaluate to.
There are a couple of different approaches to performing this analysis available in the literature: abstract interpretation \cite{popa}, (annotated) type systems \cite{popa} and abstract abstract machines \cite{aam}.
I chose to employ the last approach as it allows for derivation of the control-flow analysis from an abstract machine for \IDL{}.
The derivation technique guarantees correctness of the resulting interpreter and hence provides high confidence in the actual implementation of the machine.
I will summarize the derivation here but an interested reader should definitely acquaint themselves with the original work \cite{aam}.

We will begin with a template of a machine for terms in A-normal form presented in Figure \ref{fig:anf-abstract-machine}.
We assume that every term has an unique label $l$.
The template is parameterized by implementation of the store $\sigma$ along with five operations: $\mathit{alloc}_v$, $\mathit{alloc}_k$, $\mathit{deref}_v$, $\mathit{deref}_k$ and $\mathit{copy}_v$.
The machine uses this store both as a memory for values and continuations.
The store maps value addresses $\nu$ to values $v$ and continuation addresses $\kappa$ to continuations $k$.
The environment maps program variables to value locations.
The values on which machine operates are the following: base values $b$, primitive operations $\delta$, records with addresses as fields, closures and top-level functions.
Thanks to terms being in A-normal form, there are only two kinds of continuations which form a stack.
The stack frames $\tuple{\rho, p, e, \kappa}$ are introduced by let-bindings. They hold an environment $\rho$, a pattern $p$ to use for destructuring of a value, the body $e$ of a let expression and a pointer to the next continuation $\kappa$.
The bottom of the stack is marked by the empty continuation $\tuple{}$.

The machine configurations are pairs of a store $\sigma$ and a partial configuration $\gamma$.
This split of configuration into two parts will prove beneficial when we will be instantiating the template to obtain an abstract interpreter.
There are two classes of partial configurations.
An evaluation configuration contains an environment $\rho$, an expression $e$ and a continuation pointer $\kappa$.
A continuation configuration holds an address $\nu$ of a value that has been computed so far and a pointer $\kappa$ to a resumption which should be applied next.

The first case of the transition relation $\Rightarrow$ looks up a pointer for the variable $x$ in the environment $\rho$ and switches to the continuation mode.
It may modify the store via $\mathit{copy}$ function which will become relevant when we consider an abstract instantiation of the machine.
The next three cases deal with values by $\mathit{alloc}$ating the values in the store and switching to the continuation mode.
When the machine encounters a let-binding it allocates a continuation for the body $e$ of the expression and proceeds to evaluate the bound command $c$ with the new pointer $\kappa'$.
In case of applications and match expressions the resulting configuration is decided using auxiliary functions $\mathit{apply}$ and $\mathit{match}$ respectively.
Finally, in continuation mode, may transition if the continuation loaded from address $\kappa$ is a frame.
In such a case the machine matches the stored pattern against the value pointed-to by $\nu$.
Otherwise $\kappa$ points to a $\tuple{}$ instead and the machine has reached the final state.
The auxiliary function $\mathit{apply}$ checks what kind of function is referenced by $\nu$ and proceeds accordingly.

The machine template can now be instantiated with a store implementation in order to obtain an abstract machine.
By choosing $\mathit{Store}$ to be a mapping with infinite domain we can ensure that $\mathit{alloc}$ can always return a fresh address and the machine behaves as expected.

Let us now turn to a different instantiation of the template.
Figure \ref{fig:aam} shows the missing pieces of an abstract abstract machine for \IDL{}.
The store is represented as a pair of finite mappings from labels to sets of abstract values and continuations respectively.
The abstract values use base type names $tp$ to represent any value of that type, abstract versions of primitive operations, records, closures and top-level functions.
The abstract configuration consists of a store and a set of partial configurations.
% The abstract transition $\Rightarrow_a$ computes a



\begin{figure}
\begin{center}
\begingroup
\begin{tabular}{rl}
$\nu \in \VA{}$ & $\kappa \in \KA{}\quad l \in \mathit{Label}$\quad$\sigma \in \mathit{Store}$\\

$\delta \in \mathit{PrimOp}$ & $\subseteq \mathit{Val}^* \rightarrow Val$\\

$\rho \in \mathit{Env}$ &$= \mathit{Var} \rightarrow \VA{}$\\

$\mathit{Val} \ni v$ 
& ::= $b$ | $\delta$ 
    | \lstinline!{$r\;\nu\ldots$}!
    | $\tuple{\rho,x\ldots,e}$
    | \lstinline!(def $x$ ($x\ldots$) $e$)!\\

$\mathit{Cont} \ni k$ & ::= $\tuple{\rho, p, e, \kappa}$ | $\tuple{}$\\

$\mathit{PartialConf} \ni \gamma $
& ::= $\tuple{\rho, e, \kappa}_e $ | $\tuple{\nu, \kappa}_c$\\

$\mathit{Conf} \ni \varsigma $
& ::= $\tuple{\sigma, \gamma}$\\
\end{tabular}

\begin{tabular}{|rl|}
\hline
$\tuple{\sigma, \tuple{\rho, x, \kappa}_e}$
& $\Rightarrow \tuple{\mathit{copy}_v(\rho(x), l, \sigma), \tuple{\rho(x), \kappa}_c}$\\

$\tuple{\sigma, \tuple{\rho, b^l, \kappa}_e}$
& $\Rightarrow \tuple{\sigma', \tuple{\nu, \kappa}_c}$\\
& where $\tuple{\sigma', \nu} = \mathit{alloc}_v(b, l, \sigma)$\\

$\tuple{\sigma, \tuple{\rho, \lstinline!\{$r\;x\ldots$\}!^l, \kappa}_e}$
& $\Rightarrow \tuple{\sigma', \tuple{\nu, \kappa}_c}$\\
& where $\tuple{\sigma', \nu} = \mathit{alloc}_v(\lstinline!{$r\;\rho(x)\ldots$}!, l, \sigma)$\\

$\tuple{\sigma, \tuple{\rho, \lstinline!(fun ($x\ldots$)\ $e$)!^l, \kappa}_e}$
& $\Rightarrow \tuple{\sigma', \tuple{\nu, \kappa}_c}$\\
& where $\tuple{\sigma', \nu} = \mathit{alloc}_v(\tuple{\rho, x\ldots, e}, l,\sigma)$\\

$\tuple{\sigma, \tuple{\rho, \lstinline!(let\ $p\;c^l\;e$)!, \kappa}_e}$
& $\Rightarrow \tuple{\sigma', \tuple{\rho, c, \kappa'}_e}$\\
& where $\tuple{\sigma', \kappa'} = \mathit{alloc}_k(\tuple{\rho, p, e, \kappa}, l, \sigma)$\\

$\tuple{\sigma, \tuple{\rho, \lstinline!($x\;y\ldots$)!, \kappa}_e}$
& $\Rightarrow \mathit{apply}(\sigma, \rho(x), \rho(y)\ldots, l)$\\

$\tuple{\sigma, \tuple{\rho, \lstinline!(match\ $x\;$($p\;e$)$\ldots$)!, \kappa}_e}$
& $\Rightarrow \mathit{match}(\sigma, \rho, \rho(x), \tuple{p, e}\ldots)$\\

$\tuple{\sigma, \tuple{\nu, \kappa}_c}$
& $\Rightarrow \mathit{match}(\sigma, \rho, \nu, \kappa', \tuple{p, e})$\\
& where $\tuple{\rho, p, e, \kappa'} = \mathit{deref}_k(\sigma, \kappa)$\\[2pt]

% \hline &\\[\dimexpr-\normalbaselineskip+2pt]
\hline

$ \mathit{apply}(\sigma, \nu, \nu'\ldots, \kappa, l)$
& $ = \begin{cases}
  \tuple{\sigma, \tuple{\rho[(x \mapsto \nu') \ldots], e, \kappa}_e}\\
  \quad\text{when}\;\mathit{deref}_v(\sigma, \nu) = \tuple{\rho, x\ldots, e}\\

  \tuple{\sigma, \tuple{\rho_0[(x \mapsto \nu') \ldots], e, \kappa}_e}\\
  \quad\text{when}\;\mathit{deref}_v(\sigma, \nu) = \lstinline!(def $y\;$($x\ldots$) $e$)!\\

  \tuple{\sigma', \tuple{\nu'', \kappa}_c}\\
  \quad\text{when}\;\mathit{deref}_v(\sigma, \nu) = \delta\\
  \quad\text{and}\;\tuple{\sigma', \nu''} = \mathit{alloc}_v(\delta(\sigma(\nu')\ldots), l, \sigma)
\end{cases} $ \\

$ \mathit{match}(\sigma, \rho, \nu, \kappa, \tuple{p, e}\ldots)$
& $= \tuple{\sigma, \tuple{\rho', e', \kappa}_e}$ where $\rho'$ is the environment\\
&\quad for the first matching branch with body $e'$\\
\hline
\end{tabular}
\endgroup
\end{center}
\caption{An abstract machine for \IDL{} terms in ANF}
\label{fig:anf-abstract-machine}
\end{figure}


\begin{figure}
\begin{center}
\begingroup
\begin{tabular}{rl}
$\VA{}$ & $=\KA{}=\mathit{Label}$\\
$\widetilde{\mathit{Val}} \ni v$ 
& ::= $tp$ | $\widetilde{\delta}$
    | \lstinline!{$r\;\nu\ldots$}!
    | $\tuple{\rho,x\ldots,e}$
    | \lstinline!(def $x$ ($x\ldots$) $e$)!\\

$\sigma \in \mathit{Store} $
& $= (\VA{} \rightarrow \mathbb{P}(\widetilde{\mathit{Val}}))
  \times (\KA{} \rightarrow \mathbb{P}(\mathit{Cont}))$\\

$\mathit{alloc}_v(v, l, \tuple{\sigma_v, \sigma_k})$ 
& $= \tuple{\tuple{\sigma_v[l \mapsto \sigma_v(l)\cup\{v\}], \sigma_k}, l}$\\

$\mathit{alloc}_k(v, l, \tuple{\sigma_v, \sigma_k})$
& $= \tuple{\tuple{\sigma_v, \sigma_k[l \mapsto \sigma_k(l)\cup\{k\}]}, l}$\\

$\mathit{copy}_v(\nu, l, \tuple{\sigma_v, \sigma_k})$
& $= \tuple{\sigma_v[l \mapsto \sigma_v(l)\cup\sigma_v(\nu)], \sigma_k}$\\

$\tilde{\varsigma} \in \widetilde{\mathit{Conf}}$
& $ = Store\times\mathbb{P}(PartialConf)$\\
\hline
$\tuple{\sigma, C}$ 
& $\Rightarrow_a \tuple{\sigma'\sqcup\sigma, C\cup C'}$\\
& where $\sigma' = \{\sigma' \mid \exists c \in C. \tuple{\sigma, c} \Rightarrow \tuple{\sigma', c'} \}$\\
& and $C' = \{c' \mid \exists c \in C. \tuple{\sigma, c} \Rightarrow \tuple{\sigma', c'} \}$\\
\hline

\end{tabular}
\endgroup
\end{center}
\caption{An abstract abstract machine for \IDL{}}
\label{fig:aam}
\end{figure}

\section{Selective CPS}\label{sec:selective-cps}

\section{Selective Defunctionalization}\label{sec:selective-defun}

\section{Let Inlining}