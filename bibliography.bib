@InProceedings{one-step-at-a-time,
  author="Vesely, Ferdinand and Fisher, Kathleen",
  editor="Caires, Lu{\'i}s",
  title="One Step at a Time",
  booktitle="Programming Languages and Systems",
  year="2019",
  publisher="Springer International Publishing",
  address="Cham",
  pages="205--231",
  abstract="Big-step and small-step are two popular flavors of operational semantics. Big-step is often seen as a more natural transcription of informal descriptions, as well as being more convenient for some applications such as interpreter generation or optimization verification. Small-step allows reasoning about non-terminating computations, concurrency and interactions. It is also generally preferred for reasoning about type systems. Instead of having to manually specify equivalent semantics in both styles for different applications, it would be useful to choose one and derive the other in a systematic or, preferably, automatic way.",
  isbn="978-3-030-17184-1"
}

@inproceedings{ager-natural-semantics,
author = {Ager, Mads},
year = {2004},
month = {08},
pages = {245-261},
title = {From Natural Semantics to Abstract Machines},
volume = {3573},
journal = {Lecture Notes in Computer Science},
doi = {10.1007/11506676_16}
}

@article{refocusing,
title={Refocusing in reduction semantics},
author={Danvy, Olivier and Nielsen, Lasse R},
journal={BRICS Report Series},
volume={11},
number={26},
year={2004}
}

@inproceedings{refocusing-auto,
author = {Sieczkowski, Filip and Biernacka, Ma\l{}lgorzata and Biernacki, Dariusz},
title = {Automating Derivations of Abstract Machines from Reduction Semantics: A Generic Formalization of Refocusing in Coq},
year = {2010},
isbn = {9783642242755},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Proceedings of the 22nd International Conference on Implementation and Application of Functional Languages},
pages = {72–88},
numpages = {17},
location = {Alphen aan den Rijn, The Netherlands},
series = {IFL’10}
}

@InProceedings{refocusing-generalized,
  author =	{Malgorzata Biernacka and Witold Charatonik and Klara Zielinska},
  title =	{{Generalized Refocusing: From Hybrid Strategies to Abstract Machines}},
  booktitle =	{2nd International Conference on Formal Structures for Computation and Deduction (FSCD 2017)},
  pages =	{10:1--10:17},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-047-7},
  ISSN =	{1868-8969},
  year =	{2017},
  volume =	{84},
  editor =	{Dale Miller},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{http://drops.dagstuhl.de/opus/volltexte/2017/7718},
  URN =		{urn:nbn:de:0030-drops-77188},
  doi =		{10.4230/LIPIcs.FSCD.2017.10},
  annote =	{Keywords: reduction semantics, abstract machines, formal verification, Coq}
}

@inproceedings{reynolds,
author = {Reynolds, John C.},
title = {Definitional Interpreters for Higher-Order Programming Languages},
year = {1972},
isbn = {9781450374927},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800194.805852},
doi = {10.1145/800194.805852},
booktitle = {Proceedings of the ACM Annual Conference - Volume 2},
pages = {717–740},
numpages = {24},
keywords = {Interpreter, Language definition, LISP, Applicative language, Closure, PAL, J-operator, Order of application, Lambda calculus, GEDANKEN, Continuation, Programming language, Reference, SECD machine, Higher-order function},
location = {Boston, Massachusetts, USA},
series = {ACM ’72}
}

@inproceedings{functional-correspondence,
author = {Ager, Mads Sig and Biernacki, Dariusz and Danvy, Olivier and Midtgaard, Jan},
title = {A Functional Correspondence between Evaluators and Abstract Machines},
year = {2003},
isbn = {1581137052},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/888251.888254},
doi = {10.1145/888251.888254},
booktitle = {Proceedings of the 5th ACM SIGPLAN International Conference on Principles and Practice of Declaritive Programming},
pages = {8–19},
numpages = {12},
keywords = {abstract machines, closure conversion, defunctionalization, interpreters, transformation into continuation-passing style (CPS)},
location = {Uppsala, Sweden},
series = {PPDP ’03}
}
  
@book{popa,
author = {Nielson, Flemming and Nielson, Hanne and Hankin, Chris},
year = {1999},
month = {01},
pages = {},
title = {Principles of Program Analysis},
doi = {10.1007/978-3-662-03811-6}
}

@article{aam,
author = {Van Horn, David and Might, Matthew},
title = {Abstracting Abstract Machines},
year = {2010},
issue_date = {September 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/1932681.1863553},
doi = {10.1145/1932681.1863553},
journal = {SIGPLAN Not.},
month = sep,
pages = {51–62},
numpages = {12},
keywords = {abstract machines, abstract interpretation}
}
  
@inproceedings{Felleisen,
author = {Felleisen, Mattias and Friedman, D. P.},
title = {A Calculus for Assignments in Higher-Order Languages},
year = {1987},
isbn = {0897912152},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/41625.41654},
doi = {10.1145/41625.41654},
booktitle = {Proceedings of the 14th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
pages = {314},
numpages = {12},
location = {Munich, West Germany},
series = {POPL ’87}
}

@article{ager-call-by-need,
title = "A functional correspondence between call-by-need evaluators and lazy abstract machines",
journal = "Information Processing Letters",
volume = "90",
number = "5",
pages = "223 - 232",
year = "2004",
issn = "0020-0190",
doi = "https://doi.org/10.1016/j.ipl.2004.02.012",
url = "http://www.sciencedirect.com/science/article/pii/S0020019004000638",
author = "Mads Sig Ager and Olivier Danvy and Jan Midtgaard",
keywords = "Functional programming, Program derivation, Interpreters, Abstract machines, Closure conversion, CPS transformation, Defunctionalization",
abstract = "We bridge the gap between compositional evaluators and abstract machines for the lambda-calculus, using closure conversion, transformation into continuation-passing style, and defunctionalization of continuations. This article is a followup of our article at PPDP 2003, where we consider call by name and call by value. Here, however, we consider call by need. We derive a lazy abstract machine from an ordinary call-by-need evaluator that threads a heap of updatable cells. In this resulting abstract machine, the continuation fragment for updating a heap cell naturally appears as an ‘update marker’, an implementation technique that was invented for the Three Instruction Machine and subsequently used to construct lazy variants of Krivine's abstract machine. Tuning the evaluator leads to other implementation techniques such as unboxed values. The correctness of the resulting abstract machines is a corollary of the correctness of the original evaluators and of the program transformations used in the derivation."
}

@InProceedings{biernacki-logic-engine,
author="Biernacki, Dariusz
and Danvy, Olivier",
editor="Bruynooghe, Maurice",
title="From Interpreter to Logic Engine by Defunctionalization",
booktitle="Logic Based Program Synthesis and Transformation",
year="2004",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="143--159",
abstract="Starting from a continuation-based interpreter for a simple logic programming language, propositional Prolog with cut, we derive the corresponding logic engine in the form of an abstract machine. The derivation originates in previous work (our article at PPDP 2003) where it was applied to the lambda-calculus. The key transformation here is Reynolds's defunctionalization that transforms a tail-recursive, continuation-passing interpreter into a transition system, i.e., an abstract machine. Similar denotational and operational semantics were studied by de Bruin and de Vink (their article at TAPSOFT 1989), and we compare their study with our derivation. Additionally, we present a direct-style interpreter of propositional Prolog expressed with control operators for delimited continuations.",
isbn="978-3-540-25938-1"
}

@article{ager-monadic-evaluators,
title = "A functional correspondence between monadic evaluators and abstract machines for languages with computational effects",
journal = "Theoretical Computer Science",
volume = "342",
number = "1",
pages = "149 - 172",
year = "2005",
note = "Applied Semantics: Selected Topics",
issn = "0304-3975",
doi = "https://doi.org/10.1016/j.tcs.2005.06.008",
url = "http://www.sciencedirect.com/science/article/pii/S0304397505003439",
author = "Mads Sig Ager and Olivier Danvy and Jan Midtgaard",
keywords = "-calculus, Interpreters, Abstract machines, Closure conversion, Transformation into continuation-passing style (CPS), Defunctionalization, Monads, Effects, Proper tail recursion, Stack inspection",
abstract = "We extend our correspondence between evaluators and abstract machines from the pure setting of the λ-calculus to the impure setting of the computational λ-calculus. We show how to derive new abstract machines from monadic evaluators for the computational λ-calculus. Starting from (1) a generic evaluator parameterized by a monad and (2) a monad specifying a computational effect, we inline the components of the monad in the generic evaluator to obtain an evaluator written in a style that is specific to this computational effect. We then derive the corresponding abstract machine by closure-converting, CPS-transforming, and defunctionalizing this specific evaluator. We illustrate the construction with the identity monad, obtaining the CEK machine, and with a lifted state monad, obtaining a variant of the CEK machine with error and state. In addition, we characterize the tail-recursive stack inspection presented by Clements and Felleisen as a lifted state monad. This enables us to combine this stack-inspection monad with other monads and to construct abstract machines for languages with properly tail-recursive stack inspection and other computational effects. The construction scales to other monads—including one more properly dedicated to stack inspection than the lifted state monad—and other monadic evaluators."
}

@article{biernacka-delimited-continuations,
title={An Operational Foundation for Delimited Continuations in the CPS Hierarchy},
volume={1},
ISSN={1860-5974},
url={http://dx.doi.org/10.2168/LMCS-1(2:5)2005},
DOI={10.2168/lmcs-1(2:5)2005},
number={2},
journal={Logical Methods in Computer Science},
publisher={Logical Methods in Computer Science e.V.},
author={Biernacka, Malgorzata and Biernacki, Dariusz and Danvy, Olivier},
editor={Wadler, Philip},
year={2005},
month={Nov}
}
  
@article{flanagan-anf,
author = {Flanagan, Cormac and Sabry, Amr and Duba, Bruce F. and Felleisen, Matthias},
title = {The Essence of Compiling with Continuations},
year = {1993},
issue_date = {June 1993},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {28},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/173262.155113},
doi = {10.1145/173262.155113},
journal = {SIGPLAN Not.},
month = jun,
pages = {237–247},
numpages = {11}
}

@InProceedings{kahn-natural-semantics,
author="Kahn, G.",
editor="Brandenburg, Franz J.
and Vidal-Naquet, Guy
and Wirsing, Martin",
title="Natural semantics",
booktitle="STACS 87",
year="1987",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="22--39",
abstract="During the past few years, many researchers have begun to present semantic specifications in a style that has been strongly advocated by Plotkin in [19]. The purpose of this paper is to introduce in an intuitive manner the essential ideas of the method that we call now Natural Semantics, together with its connections to ideas in logic and computing. Natural Semantics is of interest per se and because it is used as a semantics specification formalism for an interactive computer system that we are currently building at INRIA.",
isbn="978-3-540-47419-7"
}

@article{plotkin-sos,
author = {Plotkin, Gordon},
year = {2004},
month = {07},
pages = {17-139},
title = {A Structural Approach to Operational Semantics},
volume = {60-61},
journal = {J. Log. Algebr. Program.},
doi = {10.1016/j.jlap.2004.05.001}
}

@article{scott-denotational-semantics,
author = {Scott, Dana},
title = {Data Types as Lattices},
journal = {SIAM Journal on Computing},
volume = {5},
number = {3},
pages = {522-587},
year = {1976},
doi = {10.1137/0205037},
URL = {https://doi.org/10.1137/0205037},
eprint = {https://doi.org/10.1137/0205037}
}

@InProceedings{pretty-big-step-semantics,
author="Chargu{\'e}raud, Arthur",
editor="Felleisen, Matthias
and Gardner, Philippa",
title="Pretty-Big-Step Semantics",
booktitle="Programming Languages and Systems",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="41--60",
abstract="In spite of the popularity of small-step semantics, big-step semantics remain used by many researchers. However, big-step semantics suffer from a serious duplication problem, which appears as soon as the semantics account for exceptions and/or divergence. In particular, many premises need to be copy-pasted across several evaluation rules. This duplication problem, which is particularly visible when scaling up to full-blown languages, results in formal definitions growing far bigger than necessary. Moreover, it leads to unsatisfactory redundancy in proofs. In this paper, we address the problem by introducing pretty-big-step semantics. Pretty-big-step semantics preserve the spirit of big-step semantics, in the sense that terms are directly related to their results, but they eliminate the duplication associated with big-step semantics.",
isbn="978-3-642-37036-6"
}

@book{felleisen-reduction-semantics,
  title={Semantics engineering with PLT Redex},
  author={Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew},
  year={2009},
  publisher={Mit Press}
}

@InProceedings{poulsen-deriving-pretty-big-step,
author="Bach Poulsen, Casper
and Mosses, Peter D.",
editor="Shao, Zhong",
title="Deriving Pretty-Big-Step Semantics from Small-Step Semantics",
booktitle="Programming Languages and Systems",
year="2014",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="270--289",
abstract="Big-step semantics for languages with abrupt termination and/or divergence suffer from a serious duplication problem, addressed by the novel `pretty-big-step' style presented by Chargu{\'e}raud at ESOP'13. Such rules are less concise than corresponding small-step rules, but they have the same advantages as big-step rules for program correctness proofs. Here, we show how to automatically derive pretty-big-step rules directly from small-step rules by `refocusing'. This gives the best of both worlds: we only need to write the relatively concise small-step specifications, but our reasoning can be big-step as well as small-step. The use of strictness annotations to derive small-step congruence rules gives further conciseness.",
isbn="978-3-642-54833-8"
}

@article{hannan-big-step-to-am,
  title={From operational semantics to abstract machines},
  author={Hannan, John and Miller, Dale},
  journal={Mathematical Structures in Computer Science},
  volume={2},
  number={4},
  pages={415--459},
  year={1992},
  publisher={Cambridge University Press}
}

@article{landin-secd,
  title={The mechanical evaluation of expressions},
  author={Landin, Peter J},
  journal={The computer journal},
  volume={6},
  number={4},
  pages={308--320},
  year={1964},
  publisher={The British Computer Society}
}

@article{krivine-machine,
author = {Krivine, Jean-Louis},
title = {A Call-by-Name Lambda-Calculus Machine},
year = {2007},
issue_date = {September 2007},
publisher = {Kluwer Academic Publishers},
address = {USA},
volume = {20},
number = {3},
issn = {1388-3690},
url = {https://doi.org/10.1007/s10990-007-9018-9},
doi = {10.1007/s10990-007-9018-9},
journal = {Higher Order Symbol. Comput.},
month = sep,
pages = {199–207},
numpages = {9},
keywords = {Curry-Howard correspondence, Control instruction, Lambda-calculus machine}
}

@inproceedings{felleisen-cek,
  title={Control operators, the SECD-machine, and the $\lambda$-calculus},
  author={Matthias Felleisen and Daniel P. Friedman},
  booktitle={Formal Description of Programming Concepts},
  year={1987}
}

@inproceedings{cregut-normal,
author = {Cr\'{e}gut, P.},
title = {An Abstract Machine for Lambda-Terms Normalization},
year = {1990},
isbn = {089791368X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/91556.91681},
doi = {10.1145/91556.91681},
booktitle = {Proceedings of the 1990 ACM Conference on LISP and Functional Programming},
pages = {333–340},
numpages = {8},
location = {Nice, France},
series = {LFP ’90}
}

@article{ager-interpreter-compiler,
  title={From interpreter to compiler and virtual machine: a functional derivation},
  author={Ager, Mads Sig and Biernacki, Dariusz and Danvy, Olivier and Midtgaard, Jan},
  journal={BRICS Report Series},
  volume={10},
  number={14},
  year={2003}
}

@article{danvy-object-oriented,
title = "Inter-deriving semantic artifacts for object-oriented programming",
journal = "Journal of Computer and System Sciences",
volume = "76",
number = "5",
pages = "302 - 323",
year = "2010",
note = "Workshop on Logic, Language, Information and Computation",
issn = "0022-0000",
doi = "https://doi.org/10.1016/j.jcss.2009.10.004",
url = "http://www.sciencedirect.com/science/article/pii/S0022000009000932",
author = "Olivier Danvy and Jacob Johannsen",
keywords = "Functional calculus of objects, Reduction semantics, Abstract machine, Natural semantics, Syntactic correspondence, Functional correspondence",
abstract = "We present a new abstract machine for Abadi and Cardelli's untyped non-imperative calculus of objects. This abstract machine mechanically corresponds to both the reduction semantics (i.e., small-step operational semantics) and the natural semantics (i.e., big-step operational semantics) specified in Abadi and Cardelli's monograph. To move closer to actual implementations, which use environments rather than actual substitutions, we then represent methods as closures and we present three new semantic artifacts for a version of Abadi and Cardelli's calculus with explicit substitutions: a reduction semantics, an environment-based abstract machine, and a natural semantics (i.e., an interpreter) with environments. These three new semantic artifacts mechanically correspond to each other, and the two abstract machines are bisimilar. Their significance lies in the fact that they have not been designed from scratch and then proved correct; instead, they have been inter-derived. To illustrate the inter-derivation and to make this article stand-alone, we also comprehensively treat the example of negational normalization over Boolean formulas, in appendix."
}

@inproceedings{jedynak-ltac,
author = {Jedynak, Wojciech and Biernacka, Ma\l{}gorzata and Biernacki, Dariusz},
title = {An Operational Foundation for the Tactic Language of Coq},
year = {2013},
isbn = {9781450321549},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2505879.2505890},
doi = {10.1145/2505879.2505890},
booktitle = {Proceedings of the 15th Symposium on Principles and Practice of Declarative Programming},
pages = {25–36},
numpages = {12},
keywords = {proof assistant Coq, reduction semantics, tactics, natural semantics, abstract machine},
location = {Madrid, Spain},
series = {PPDP ’13}
}

@inproceedings{pirog-stg,
author = {Pirog, Maciej and Biernacki, Dariusz},
title = {A Systematic Derivation of the STG Machine Verified in Coq},
year = {2010},
isbn = {9781450302524},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1863523.1863528},
doi = {10.1145/1863523.1863528},
booktitle = {Proceedings of the Third ACM Haskell Symposium on Haskell},
pages = {25–36},
numpages = {12},
keywords = {verification, derivation, abstract machine, natural semantics, stg, coq},
location = {Baltimore, Maryland, USA},
series = {Haskell ’10}
}

@InProceedings{design-and-correctness-cfa,
author="Banerjee, Anindya
and Heintze, Nevin
and Riecke, Jon G.",
editor="Kobayashi, Naoki
and Pierce, Benjamin C.",
title="Design and Correctness of Program Transformations Based on Control-Flow Analysis",
booktitle="Theoretical Aspects of Computer Software",
year="2001",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="420--447",
abstract="We show how control-flow-based program transformations in functional languages can be proven correct. The method relies upon ``defunctionalization,'' a mapping from a higher-order language to a first-order language.W e first show that defunctionalization is correct; using this proof and common semantic techniques, we then show how two program transformations --- flow-based inlining and lightweight defunctionalization --- can be proven correct.",
isbn="978-3-540-45500-4"
}

@article{leroy-zinc,
  title={The ZINC experiment: an economical implementation of the ML language},
  author={Leroy, Xavier},
  year={1990}
}

@article{abel-nbe,
  title={Normalization by Evaluation: Dependent Types and Impredicativity},
  author={Abel, Andreas},
  year={2013}
}

